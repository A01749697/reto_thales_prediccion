# -*- coding: utf-8 -*-
"""Copia de MAN NIMAMES de Copia de Copia de Taller - TS Predict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uXCc1rozmFew2hHKUnM_GEXpqEQU38Tf
"""

import pandas as pd

import matplotlib.pyplot as plt

from statsmodels.tsa.arima.model import ARIMA

from google.colab import drive
drive.mount('/content/drive')

import os
DIR = "/content/drive/MyDrive/ColabNotebooks"
os.chdir(DIR)

df = pd.read_csv("df_filtrado.csv")

df_f = df

df_f['fecha_hecho'] = pd.to_datetime(df_f['fecha_hecho'], format='%Y-%m-%d %H:%M:%S', errors='coerce')

fecha_inicio = pd.to_datetime("2023-01-01")
fecha_fin = pd.to_datetime("2024-06-30")

# Aplicar el filtro entre estas dos fechas
df_f = df_f[(df_f['fecha_hecho'] >= fecha_inicio) & (df_f['fecha_hecho'] <= fecha_fin)]

map_prioridad = {
    'BAJA PRIORIDAD': 0,
    'ALTA PRIORIDAD': 1
}

# Aplicar el mapeo y agregar una nueva columna llamada 'prioridad_numeric'
df_f['prioridad_numeric'] = df_f['prioridad_atencion'].map(map_prioridad)

# Crear un diccionario para mapear las alcaldías a valores numéricos
map_alcaldia = {
    'IZTAPALAPA': 1,
    'CUAUHTEMOC': 2,
    'GUSTAVO A. MADERO': 3,
    'BENITO JUAREZ': 4,
    'COYOACAN': 5,
    'ALVARO OBREGON': 6,
    'TLALPAN': 7,
    'MIGUEL HIDALGO': 8,
    'VENUSTIANO CARRANZA': 9,
    'IZTACALCO': 10,
    'AZCAPOTZALCO': 11,
    'XOCHIMILCO': 12,
    'TLAHUAC': 13,
    'LA MAGDALENA CONTRERAS': 14,
    'CUAJIMALPA DE MORELOS': 15,
    'MILPA ALTA': 16
}

# Aplicar el mapeo y agregar una nueva columna llamada 'alcaldia_numeric'
df_f['alcaldia_numeric'] = df_f['alcaldia_hecho'].map(map_alcaldia)

map_zona = {
    'SUR': 1,
    'ORIENTE': 2,
    'NORTE': 3,
    'PONIENTE': 4,
    'CENTRO': 5
}

# Aplicar el mapeo y agregar una nueva columna llamada 'zona_numeric' sin eliminar las demás columnas
df_f['zona_numeric'] = df_f['zona'].map(map_zona)

map_categoria_delito = {
    'DELITO DE BAJO IMPACTO': 1,
    'ROBO A TRANSEUNTE EN VÍA PÚBLICA CON Y SIN VIOLENCIA': 2,
    'ROBO DE VEHÍCULO CON Y SIN VIOLENCIA': 3,
    'HECHO NO DELICTIVO': 4,
    'VIOLACIÓN': 5,
    'ROBO A NEGOCIO CON VIOLENCIA': 6,
    'ROBO A PASAJERO A BORDO DEL METRO CON Y SIN VIOLENCIA': 7,
    'ROBO A REPARTIDOR CON Y SIN VIOLENCIA': 8,
    'HOMICIDIO DOLOSO': 9,
    'ROBO A PASAJERO A BORDO DE MICROBUS CON Y SIN VIOLENCIA': 10,
    'LESIONES DOLOSAS POR DISPARO DE ARMA DE FUEGO': 11,
    'ROBO A CASA HABITACIÓN CON VIOLENCIA': 12,
    'ROBO A CUENTAHABIENTE SALIENDO DEL CAJERO CON VIOLENCIA': 13,
    'ROBO A PASAJERO A BORDO DE TAXI CON VIOLENCIA': 14,
    'ROBO A TRANSPORTISTA CON Y SIN VIOLENCIA': 15,
    'SECUESTRO': 16
}

# Aplicar el mapeo y agregar una nueva columna llamada 'categoria_delito_numeric'
df_f['categoria_delito_numeric'] = df_f['categoria_delito'].map(map_categoria_delito)

df_f = df_f.drop('indice_normalizado', axis=1)
df_f = df_f.drop('indice_total', axis=1)
df_f = df_f.drop('zona', axis=1)

# modificar los indices
df_f.reset_index(drop=True, inplace=True)

# Paso 1: Identificar clases con menos de 2 instancias
clases_enough_date = df_f['fecha_hecho'].value_counts()
clases_enough_date = clases_enough_date[clases_enough_date < 2].index.tolist()
print("\nClases Raras a Eliminar:", len(clases_enough_date))

# Paso 2: Eliminar las clases raras del DataFrame
df_filtrado = df_f[~df_f['fecha_hecho'].isin(clases_enough_date)]

# Verificar la distribución de clases después del filtrado
print("\nDistribución de Clases Después de Filtrar:")
print(df_filtrado['categoria_delito'].value_counts())

# Paso 1: Identificar clases con menos de 2 instancias
clases_enough_fiscalia = df_filtrado['fiscalia'].value_counts()
clases_enough_fiscalia = clases_enough_fiscalia[clases_enough_fiscalia < 2].index.tolist()
print("\nClases Raras a Eliminar:", len(clases_enough_fiscalia))

# Paso 2: Eliminar las clases raras del DataFrame
df_filtrado = df_filtrado[~df_filtrado['fecha_hecho'].isin(clases_enough_fiscalia)]

# Verificar la distribución de clases después del filtrado
print("\nDistribución de Clases Después de Filtrar:")
print(df_filtrado['categoria_delito'].value_counts())

# Paso 1: Identificar clases con menos de 2 instancias
clases_enough_agencia = df_filtrado['agencia'].value_counts()
clases_enough_agencia = clases_enough_agencia[clases_enough_agencia < 2].index.tolist()
print("\nClases Raras a Eliminar:", len(clases_enough_agencia))

# Paso 2: Eliminar las clases raras del DataFrame
df_filtrado = df_filtrado[~df_filtrado['fecha_hecho'].isin(clases_enough_agencia)]

# Verificar la distribución de clases después del filtrado
print("\nDistribución de Clases Después de Filtrar:")
print(df_filtrado['categoria_delito'].value_counts())

# Paso 1: Identificar clases con menos de 2 instancias
clases_enough_col = df_filtrado['colonia_hecho'].value_counts()
clases_enough_col = clases_enough_col[clases_enough_col < 2].index.tolist()
print("\nClases Raras a Eliminar:", len(clases_enough_col))

# Paso 2: Eliminar las clases raras del DataFrame
df_filtrado = df_filtrado[~df_filtrado['fecha_hecho'].isin(clases_enough_col)]

# Verificar la distribución de clases después del filtrado
print("\nDistribución de Clases Después de Filtrar:")
print(df_filtrado['categoria_delito'].value_counts())

# Paso 1: Identificar clases con menos de 2 instancias
clases_enough = df_filtrado['colonia_catalogo'].value_counts()
clases_enough = clases_enough[clases_enough < 2].index.tolist()
print("\nClases Raras a Eliminar:", len(clases_enough))

# Paso 2: Eliminar las clases raras del DataFrame
df_filtrado = df_filtrado[~df_filtrado['fecha_hecho'].isin(clases_enough)]

# Verificar la distribución de clases después del filtrado
print("\nDistribución de Clases Después de Filtrar:")
print(df_filtrado['categoria_delito'].value_counts())

# Paso 1: Identificar clases con menos de 2 instancias
clases_enough = df_filtrado['delito'].value_counts()
clases_enough = clases_enough[clases_enough < 2].index.tolist()
print("\nClases Raras a Eliminar:", len(clases_enough))

# Paso 2: Eliminar las clases raras del DataFrame
df_filtrado = df_filtrado[~df_filtrado['fecha_hecho'].isin(clases_enough)]

# Verificar la distribución de clases después del filtrado
print("\nDistribución de Clases Después de Filtrar:")
print(df_filtrado['categoria_delito'].value_counts())

# Paso 1: Identificar clases con menos de 2 instancias
clases_enough = df_filtrado['unidad_investigacion'].value_counts()
clases_enough = clases_enough[clases_enough < 2].index.tolist()
print("\nClases Raras a Eliminar:", len(clases_enough))

# Paso 2: Eliminar las clases raras del DataFrame
df_filtrado = df_filtrado[~df_filtrado['fecha_hecho'].isin(clases_enough)]

# Verificar la distribución de clases después del filtrado
print("\nDistribución de Clases Después de Filtrar:")
print(df_filtrado['categoria_delito'].value_counts())

df_filtrado = df_filtrado.drop('fecha_inicio', axis=1)
df_filtrado = df_filtrado.drop('categoria_delito', axis=1)

df.head()

# Asegúrate de que la columna 'fecha_hecho' está en formato datetime
df_filtrado['fecha_hecho'] = pd.to_datetime(df_filtrado['fecha_hecho'])

# Agrupar los datos por fecha y por prioridad para contar el número de delitos por día en cada categoría
df_agrupado = df_filtrado.groupby([df_f['fecha_hecho'].dt.date, 'prioridad_atencion']).size().unstack(fill_value=0)

# Convertir el índice de 'fecha_hecho' a un índice de tipo fecha para series de tiempo
df_agrupado.index = pd.to_datetime(df_agrupado.index)

# Ajustar el modelo ARIMA para ALTA PRIORIDAD
model_alta = ARIMA(df_agrupado['ALTA PRIORIDAD'], order=(5,1,0))  # Ajusta el orden según tus datos
model_fit_alta = model_alta.fit()

# Predecir los próximos 8 días para ALTA PRIORIDAD
forecast_alta = model_fit_alta.forecast(steps=8)
print("Predicción para ALTA PRIORIDAD en los próximos 8 días:")
print(forecast_alta)

# Ajustar el modelo ARIMA para BAJA PRIORIDAD
model_baja = ARIMA(df_agrupado['BAJA PRIORIDAD'], order=(5,1,0))  # Ajusta el orden según tus datos
model_fit_baja = model_baja.fit()

# Predecir los próximos 8 días para BAJA PRIORIDAD
forecast_baja = model_fit_baja.forecast(steps=8)
print("Predicción para BAJA PRIORIDAD en los próximos 8 días:")
print(forecast_baja)

# Filtrar los datos para que solo muestre a partir de 2024
df_agrupado_2024 = df_agrupado[df_agrupado.index >= pd.to_datetime('2024-01-01')]

# Graficar la serie histórica y predicción para ALTA PRIORIDAD
plt.figure(figsize=(10,6))
plt.plot(df_agrupado_2024.index, df_agrupado_2024['ALTA PRIORIDAD'], label="Histórico ALTA PRIORIDAD")
plt.plot(pd.date_range(df_agrupado_2024.index[-1], periods=9, freq='D')[1:], forecast_alta, label="Predicción ALTA PRIORIDAD", linestyle='--')
plt.legend()
plt.title("Predicción de delitos ALTA PRIORIDAD para los próximos 8 días")
plt.xlabel("Fecha")
plt.ylabel("Número de delitos")
plt.show()

# Graficar la serie histórica y predicción para BAJA PRIORIDAD
plt.figure(figsize=(10,6))
plt.plot(df_agrupado_2024.index, df_agrupado_2024['BAJA PRIORIDAD'], label="Histórico BAJA PRIORIDAD")
plt.plot(pd.date_range(df_agrupado_2024.index[-1], periods=9, freq='D')[1:], forecast_baja, label="Predicción BAJA PRIORIDAD", linestyle='--')
plt.legend()
plt.title("Predicción de delitos BAJA PRIORIDAD para los próximos 8 días")
plt.xlabel("Fecha")
plt.ylabel("Número de delitos")
plt.show()